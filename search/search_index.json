{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Harbor on EKS: Streamlined Deployment for Vulnerability Scanning Note : We're excited to announce that our next major update will focus on modularizing this configuration, making it even easier to customize and use different components of the code independently. Easily deploy Harbor, an open-source container registry and vulnerability scanning platform, on Amazon EKS using OpenTofu. Overview This project provides an automated, infrastructure-as-code solution for deploying Harbor on Amazon EKS. It's designed to simplify the process of setting up a robust, production-ready vulnerability scanning solution suitable for organizations of all sizes. Features and Benefits Effortless Deployment : Get Harbor up and running on Amazon EKS with just a few commands Built to Scale : Uses EFS (Elastic File System) for persistent storage, so you can grow with ease Rock-Solid Security : Configures RDS (Relational Database Service) for a robust and secure database backend Networking Made Easy : Takes care of all the necessary networking components and security groups Smart Load Balancing : Implements AWS Load Balancer Controller for smooth traffic management Peace of Mind : Includes a comprehensive test suite to ensure everything's working as it should Time is Money : Dramatically reduces the time it takes to deploy a production-ready Harbor instance Budget-Friendly : Efficiently uses AWS services to keep your costs in check Your Harbor, Your Way : Easily customizable to fit your organization's unique needs Best Practices Baked In : Implements AWS and Kubernetes best practices right out of the box Quick Start git clone https://github.com/devsecflow/deploy-harbor-eks.git cd deploy-harbor-eks/tofu export TF_VAR_db_password=$(openssl rand -base64 16) tofu init tofu apply Documentation For more detailed information, please refer to the following guides: Prerequisites : Tools and configurations needed before deployment Quick Start Guide : Detailed steps to get up and running Configuration Guide : How to customize your Harbor on EKS deployment Post-Deployment Steps : What to do after successful deployment Testing : Running and understanding the test suite Continuous Integration : Our CI/CD setup using GitHub Actions Security Considerations : Security features and best practices Branching Strategy : Our Git branching model Contributing Guidelines : How to contribute to this project About DevSecFlow : Information about the maintainers of this project Directory Structure \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 docs/ \u251c\u2500\u2500 test \u2502 \u251c\u2500\u2500 Makefile \u2502 \u251c\u2500\u2500 .tflint.hcl \u2502 \u251c\u2500\u2500 go.mod \u2502 \u2514\u2500\u2500 harbor_test.go \u2514\u2500\u2500 tofu \u251c\u2500\u2500 csi.tf \u251c\u2500\u2500 efs.tf \u251c\u2500\u2500 eks.tf \u251c\u2500\u2500 harbor.tf \u251c\u2500\u2500 ingress.tf \u251c\u2500\u2500 pv.tf \u251c\u2500\u2500 rds.tf \u251c\u2500\u2500 sg.tf \u251c\u2500\u2500 tofu.tf \u251c\u2500\u2500 variables.tf \u2514\u2500\u2500 vpc.tf Support Need help? Open an issue or contact us at devsecflow.com . License This project is licensed under the MIT License - see the LICENSE file for details.","title":"Home"},{"location":"#harbor-on-eks-streamlined-deployment-for-vulnerability-scanning","text":"Note : We're excited to announce that our next major update will focus on modularizing this configuration, making it even easier to customize and use different components of the code independently. Easily deploy Harbor, an open-source container registry and vulnerability scanning platform, on Amazon EKS using OpenTofu.","title":"Harbor on EKS: Streamlined Deployment for Vulnerability Scanning"},{"location":"#overview","text":"This project provides an automated, infrastructure-as-code solution for deploying Harbor on Amazon EKS. It's designed to simplify the process of setting up a robust, production-ready vulnerability scanning solution suitable for organizations of all sizes.","title":"Overview"},{"location":"#features-and-benefits","text":"Effortless Deployment : Get Harbor up and running on Amazon EKS with just a few commands Built to Scale : Uses EFS (Elastic File System) for persistent storage, so you can grow with ease Rock-Solid Security : Configures RDS (Relational Database Service) for a robust and secure database backend Networking Made Easy : Takes care of all the necessary networking components and security groups Smart Load Balancing : Implements AWS Load Balancer Controller for smooth traffic management Peace of Mind : Includes a comprehensive test suite to ensure everything's working as it should Time is Money : Dramatically reduces the time it takes to deploy a production-ready Harbor instance Budget-Friendly : Efficiently uses AWS services to keep your costs in check Your Harbor, Your Way : Easily customizable to fit your organization's unique needs Best Practices Baked In : Implements AWS and Kubernetes best practices right out of the box","title":"Features and Benefits"},{"location":"#quick-start","text":"git clone https://github.com/devsecflow/deploy-harbor-eks.git cd deploy-harbor-eks/tofu export TF_VAR_db_password=$(openssl rand -base64 16) tofu init tofu apply","title":"Quick Start"},{"location":"#documentation","text":"For more detailed information, please refer to the following guides: Prerequisites : Tools and configurations needed before deployment Quick Start Guide : Detailed steps to get up and running Configuration Guide : How to customize your Harbor on EKS deployment Post-Deployment Steps : What to do after successful deployment Testing : Running and understanding the test suite Continuous Integration : Our CI/CD setup using GitHub Actions Security Considerations : Security features and best practices Branching Strategy : Our Git branching model Contributing Guidelines : How to contribute to this project About DevSecFlow : Information about the maintainers of this project","title":"Documentation"},{"location":"#directory-structure","text":"\u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 docs/ \u251c\u2500\u2500 test \u2502 \u251c\u2500\u2500 Makefile \u2502 \u251c\u2500\u2500 .tflint.hcl \u2502 \u251c\u2500\u2500 go.mod \u2502 \u2514\u2500\u2500 harbor_test.go \u2514\u2500\u2500 tofu \u251c\u2500\u2500 csi.tf \u251c\u2500\u2500 efs.tf \u251c\u2500\u2500 eks.tf \u251c\u2500\u2500 harbor.tf \u251c\u2500\u2500 ingress.tf \u251c\u2500\u2500 pv.tf \u251c\u2500\u2500 rds.tf \u251c\u2500\u2500 sg.tf \u251c\u2500\u2500 tofu.tf \u251c\u2500\u2500 variables.tf \u2514\u2500\u2500 vpc.tf","title":"Directory Structure"},{"location":"#support","text":"Need help? Open an issue or contact us at devsecflow.com .","title":"Support"},{"location":"#license","text":"This project is licensed under the MIT License - see the LICENSE file for details.","title":"License"},{"location":"ABOUT_DEVSECFLOW/","text":"About DevSecFlow DevSecFlow is a leading cybersecurity consulting firm specializing in innovative solutions for secure software development and deployment. This project is maintained by our team of experts committed to enhancing organizations' security postures through open-source tools and best practices. Our Approach At DevSecFlow, we offer: Comprehensive Assessment and Strategic Planning Integration of Leading Open-Source Technologies Automated Security and Orchestration Processes Ongoing Support and Continuous Improvement Customization for Industry-Specific Challenges Why Choose DevSecFlow Tailored Solutions : We understand that every organization has unique challenges. Our solutions are customized to meet your specific needs and industry requirements. Open-Source Expertise : We leverage leading open-source tools like Harbor, OPA, and Terraform to build scalable, adaptable security solutions free from vendor lock-in. Continuous Improvement : We provide ongoing support, regular updates, and training to keep your security practices effective and resilient. Regulatory Compliance : Our solutions are designed with compliance in mind, helping you meet industry standards and regulations. Proven Track Record : Our team has successfully led major cybersecurity initiatives at top firms including GitLab, Salesforce, Allstate, Grail, and Booz Allen Hamilton. Our Commitment to Open Source By maintaining projects like this Harbor on EKS deployment, we demonstrate our commitment to the open-source community and our belief in the power of collaborative security solutions. We encourage contributions and feedback from the community, as we believe that diverse perspectives lead to more robust and effective security practices. Learn More To explore how DevSecFlow can further enhance your cybersecurity practices or to learn more about our services, visit us at devsecflow.com or contact us directly. Together, we can build a more secure digital world.","title":"About DevSecFlow"},{"location":"ABOUT_DEVSECFLOW/#about-devsecflow","text":"DevSecFlow is a leading cybersecurity consulting firm specializing in innovative solutions for secure software development and deployment. This project is maintained by our team of experts committed to enhancing organizations' security postures through open-source tools and best practices.","title":"About DevSecFlow"},{"location":"ABOUT_DEVSECFLOW/#our-approach","text":"At DevSecFlow, we offer: Comprehensive Assessment and Strategic Planning Integration of Leading Open-Source Technologies Automated Security and Orchestration Processes Ongoing Support and Continuous Improvement Customization for Industry-Specific Challenges","title":"Our Approach"},{"location":"ABOUT_DEVSECFLOW/#why-choose-devsecflow","text":"Tailored Solutions : We understand that every organization has unique challenges. Our solutions are customized to meet your specific needs and industry requirements. Open-Source Expertise : We leverage leading open-source tools like Harbor, OPA, and Terraform to build scalable, adaptable security solutions free from vendor lock-in. Continuous Improvement : We provide ongoing support, regular updates, and training to keep your security practices effective and resilient. Regulatory Compliance : Our solutions are designed with compliance in mind, helping you meet industry standards and regulations. Proven Track Record : Our team has successfully led major cybersecurity initiatives at top firms including GitLab, Salesforce, Allstate, Grail, and Booz Allen Hamilton.","title":"Why Choose DevSecFlow"},{"location":"ABOUT_DEVSECFLOW/#our-commitment-to-open-source","text":"By maintaining projects like this Harbor on EKS deployment, we demonstrate our commitment to the open-source community and our belief in the power of collaborative security solutions. We encourage contributions and feedback from the community, as we believe that diverse perspectives lead to more robust and effective security practices.","title":"Our Commitment to Open Source"},{"location":"ABOUT_DEVSECFLOW/#learn-more","text":"To explore how DevSecFlow can further enhance your cybersecurity practices or to learn more about our services, visit us at devsecflow.com or contact us directly. Together, we can build a more secure digital world.","title":"Learn More"},{"location":"BRANCHING_STRATEGY/","text":"Branching Strategy For our open-source project, we've adopted a simplified GitHub Flow-inspired strategy. This approach balances flexibility with best practices, making it easier for contributors while maintaining code quality. Core Principles The main branch is always deployable. Work is done in feature branches. Pull Requests (PRs) are the unit of review and integration. Continuous Integration (CI) runs on all branches and PRs. Releases are tagged directly from main . Detailed Workflow Main Branch main : This branch always contains production-ready code. Direct commits to main are not allowed; changes come through Pull Requests. Feature Branches Create a branch from main for each new feature, bug fix, or improvement. Use a clear, descriptive name for your branch, e.g.: feature/add-efs-encryption bugfix/rds-connection-issue docs/update-deployment-guide Working in Branches Create your branch from the latest main . Make your changes, committing often with clear, descriptive commit messages. Push your branch to the remote repository regularly. Open a Pull Request early for discussion, marking it as \"Draft\" if it's not ready for review. Pull Requests When your work is ready for review, open a Pull Request (or mark it \"Ready for Review\" if it was a draft). Provide a clear description of the changes and the motivation behind them. Link any related issues in the PR description. Engage in code review discussions. Make requested changes in new commits in your branch. Once approved and all CI checks pass, the PR can be merged. Continuous Integration Our CI pipeline runs on all branches and Pull Requests. All checks must pass before a PR can be merged. CI includes automated tests, linting, and security scans. Merging We use \"Squash and Merge\" for most PRs to keep the main branch history clean. The PR title becomes the commit message on main , so ensure it's descriptive. Releases We tag releases directly from the main branch. Use semantic versioning for release tags (e.g., v1.2.3). Create a GitHub Release for each tag, detailing the changes. Hotfixes For urgent fixes to production, create a hotfix/ branch from the latest release tag. Follow the normal PR process, but merge directly to main . After merging, immediately create a new release with an incremented patch version. Best Practices Keep branches short-lived. Aim to merge within a few days. Regularly sync your feature branch with main to reduce merge conflicts. Write clear, concise commit messages. Use draft PRs for work-in-progress to signal early and get feedback. Engage actively in code reviews, both as an author and a reviewer. Benefits of This Strategy Simplicity: Easy to understand and follow for new contributors. Flexibility: Accommodates various contribution patterns and frequencies. Continuous Delivery: Always having a deployable main branch enables frequent releases. Quality Control: All changes go through PR review and CI checks. Community-Friendly: Aligns well with GitHub's features and open-source collaboration patterns. This strategy aims to strike a balance between structure and flexibility, making it easier for contributors to participate while maintaining high code quality standards. It's designed to be inclusive of both frequent and occasional contributors, which is crucial for open-source projects. Remember, while this is our recommended workflow, we're open to adjusting it based on the project's and community's needs. If you have suggestions for improvements, please open an issue for discussion.","title":"Branching Strategy"},{"location":"BRANCHING_STRATEGY/#branching-strategy","text":"For our open-source project, we've adopted a simplified GitHub Flow-inspired strategy. This approach balances flexibility with best practices, making it easier for contributors while maintaining code quality.","title":"Branching Strategy"},{"location":"BRANCHING_STRATEGY/#core-principles","text":"The main branch is always deployable. Work is done in feature branches. Pull Requests (PRs) are the unit of review and integration. Continuous Integration (CI) runs on all branches and PRs. Releases are tagged directly from main .","title":"Core Principles"},{"location":"BRANCHING_STRATEGY/#detailed-workflow","text":"","title":"Detailed Workflow"},{"location":"BRANCHING_STRATEGY/#main-branch","text":"main : This branch always contains production-ready code. Direct commits to main are not allowed; changes come through Pull Requests.","title":"Main Branch"},{"location":"BRANCHING_STRATEGY/#feature-branches","text":"Create a branch from main for each new feature, bug fix, or improvement. Use a clear, descriptive name for your branch, e.g.: feature/add-efs-encryption bugfix/rds-connection-issue docs/update-deployment-guide","title":"Feature Branches"},{"location":"BRANCHING_STRATEGY/#working-in-branches","text":"Create your branch from the latest main . Make your changes, committing often with clear, descriptive commit messages. Push your branch to the remote repository regularly. Open a Pull Request early for discussion, marking it as \"Draft\" if it's not ready for review.","title":"Working in Branches"},{"location":"BRANCHING_STRATEGY/#pull-requests","text":"When your work is ready for review, open a Pull Request (or mark it \"Ready for Review\" if it was a draft). Provide a clear description of the changes and the motivation behind them. Link any related issues in the PR description. Engage in code review discussions. Make requested changes in new commits in your branch. Once approved and all CI checks pass, the PR can be merged.","title":"Pull Requests"},{"location":"BRANCHING_STRATEGY/#continuous-integration","text":"Our CI pipeline runs on all branches and Pull Requests. All checks must pass before a PR can be merged. CI includes automated tests, linting, and security scans.","title":"Continuous Integration"},{"location":"BRANCHING_STRATEGY/#merging","text":"We use \"Squash and Merge\" for most PRs to keep the main branch history clean. The PR title becomes the commit message on main , so ensure it's descriptive.","title":"Merging"},{"location":"BRANCHING_STRATEGY/#releases","text":"We tag releases directly from the main branch. Use semantic versioning for release tags (e.g., v1.2.3). Create a GitHub Release for each tag, detailing the changes.","title":"Releases"},{"location":"BRANCHING_STRATEGY/#hotfixes","text":"For urgent fixes to production, create a hotfix/ branch from the latest release tag. Follow the normal PR process, but merge directly to main . After merging, immediately create a new release with an incremented patch version.","title":"Hotfixes"},{"location":"BRANCHING_STRATEGY/#best-practices","text":"Keep branches short-lived. Aim to merge within a few days. Regularly sync your feature branch with main to reduce merge conflicts. Write clear, concise commit messages. Use draft PRs for work-in-progress to signal early and get feedback. Engage actively in code reviews, both as an author and a reviewer.","title":"Best Practices"},{"location":"BRANCHING_STRATEGY/#benefits-of-this-strategy","text":"Simplicity: Easy to understand and follow for new contributors. Flexibility: Accommodates various contribution patterns and frequencies. Continuous Delivery: Always having a deployable main branch enables frequent releases. Quality Control: All changes go through PR review and CI checks. Community-Friendly: Aligns well with GitHub's features and open-source collaboration patterns. This strategy aims to strike a balance between structure and flexibility, making it easier for contributors to participate while maintaining high code quality standards. It's designed to be inclusive of both frequent and occasional contributors, which is crucial for open-source projects. Remember, while this is our recommended workflow, we're open to adjusting it based on the project's and community's needs. If you have suggestions for improvements, please open an issue for discussion.","title":"Benefits of This Strategy"},{"location":"CONFIGURATION/","text":"Configuration Guide This guide explains how to configure your Harbor on EKS deployment, including key variables and authentication options. Both OpenTofu and Terraform can be used for this setup. Key Variables Create a terraform.tfvars file in the tofu or terraform directory with your specific values: region = \"us-west-2\" cluster_name = \"my-harbor-cluster\" cert_arn = \"arn:aws:acm:us-west-2:123456789012:certificate/12345678-1234-1234-1234-123456789012\" domain_name = \"harbor.example.com\" vpc_cidr = \"10.0.0.0/16\" region : AWS region for deployment cluster_name : Name for your EKS cluster cert_arn : ARN of the ACM certificate for HTTPS domain_name : Domain name for Harbor vpc_cidr : Your VPC CIDR block Notes You can use either OpenTofu or Terraform to manage this configuration. Terraform is a more mature and stable option if you're concerned about potential future changes in OpenTofu, which is still in development. Authentication Configuration Harbor supports multiple authentication methods. You can configure the authentication mode in the harbor.tf file, whether you're using OpenTofu or Terraform. Here are the options: Database Authentication (Default) This is enabled by default. No additional configuration is needed. LDAP Authentication To enable LDAP authentication, update the auth section in harbor.tf as follows: auth = { mode = \"ldap_auth\" ldap = { enabled = true url = \"ldaps://your-ldap-server.com\" searchDN = \"cn=admin,dc=example,dc=com\" searchPassword = \"your-ldap-admin-password\" baseDN = \"dc=example,dc=com\" filter = \"(objectClass=person)\" uid = \"uid\" scope = \"2\" timeout = 5 } } Adjust the LDAP settings according to your LDAP server configuration. OIDC Authentication To enable OIDC authentication, update the auth section in harbor.tf as follows: auth = { mode = \"oidc_auth\" oidc = { enabled = true name = \"Your OIDC Provider\" endpoint = \"https://your-oidc-provider.com\" clientId = \"your-client-id\" clientSecret = \"your-client-secret\" groupsClaim = \"groups\" adminGroup = \"harbor-admins\" verifyToken = false } } Replace the OIDC settings with your OIDC provider's configuration. Applying Configuration Changes After making changes to your configuration, you\u2019ll need to review and apply those changes based on whether you're using OpenTofu or Terraform : OpenTofu Review your changes: bash tofu plan Apply the changes: bash tofu apply Terraform (as an alternative to OpenTofu) Review your changes: bash terraform plan Apply the changes: bash terraform apply Note: If you encounter any issues with OpenTofu due to its ongoing development, Terraform provides a more stable alternative for managing the configuration and applying changes. Security Recommendations Always handle sensitive information like passwords, client secrets, and tokens securely. It's recommended to store these in AWS Secrets Manager or using environment variables. Avoid hard-coding sensitive data directly into your configuration files. For more detailed information about Harbor's configuration options, refer to the official Harbor documentation .","title":"Configuration"},{"location":"CONFIGURATION/#configuration-guide","text":"This guide explains how to configure your Harbor on EKS deployment, including key variables and authentication options. Both OpenTofu and Terraform can be used for this setup.","title":"Configuration Guide"},{"location":"CONFIGURATION/#key-variables","text":"Create a terraform.tfvars file in the tofu or terraform directory with your specific values: region = \"us-west-2\" cluster_name = \"my-harbor-cluster\" cert_arn = \"arn:aws:acm:us-west-2:123456789012:certificate/12345678-1234-1234-1234-123456789012\" domain_name = \"harbor.example.com\" vpc_cidr = \"10.0.0.0/16\" region : AWS region for deployment cluster_name : Name for your EKS cluster cert_arn : ARN of the ACM certificate for HTTPS domain_name : Domain name for Harbor vpc_cidr : Your VPC CIDR block","title":"Key Variables"},{"location":"CONFIGURATION/#notes","text":"You can use either OpenTofu or Terraform to manage this configuration. Terraform is a more mature and stable option if you're concerned about potential future changes in OpenTofu, which is still in development.","title":"Notes"},{"location":"CONFIGURATION/#authentication-configuration","text":"Harbor supports multiple authentication methods. You can configure the authentication mode in the harbor.tf file, whether you're using OpenTofu or Terraform. Here are the options:","title":"Authentication Configuration"},{"location":"CONFIGURATION/#database-authentication-default","text":"This is enabled by default. No additional configuration is needed.","title":"Database Authentication (Default)"},{"location":"CONFIGURATION/#ldap-authentication","text":"To enable LDAP authentication, update the auth section in harbor.tf as follows: auth = { mode = \"ldap_auth\" ldap = { enabled = true url = \"ldaps://your-ldap-server.com\" searchDN = \"cn=admin,dc=example,dc=com\" searchPassword = \"your-ldap-admin-password\" baseDN = \"dc=example,dc=com\" filter = \"(objectClass=person)\" uid = \"uid\" scope = \"2\" timeout = 5 } } Adjust the LDAP settings according to your LDAP server configuration.","title":"LDAP Authentication"},{"location":"CONFIGURATION/#oidc-authentication","text":"To enable OIDC authentication, update the auth section in harbor.tf as follows: auth = { mode = \"oidc_auth\" oidc = { enabled = true name = \"Your OIDC Provider\" endpoint = \"https://your-oidc-provider.com\" clientId = \"your-client-id\" clientSecret = \"your-client-secret\" groupsClaim = \"groups\" adminGroup = \"harbor-admins\" verifyToken = false } } Replace the OIDC settings with your OIDC provider's configuration.","title":"OIDC Authentication"},{"location":"CONFIGURATION/#applying-configuration-changes","text":"After making changes to your configuration, you\u2019ll need to review and apply those changes based on whether you're using OpenTofu or Terraform :","title":"Applying Configuration Changes"},{"location":"CONFIGURATION/#opentofu","text":"Review your changes: bash tofu plan Apply the changes: bash tofu apply","title":"OpenTofu"},{"location":"CONFIGURATION/#terraform-as-an-alternative-to-opentofu","text":"Review your changes: bash terraform plan Apply the changes: bash terraform apply Note: If you encounter any issues with OpenTofu due to its ongoing development, Terraform provides a more stable alternative for managing the configuration and applying changes.","title":"Terraform (as an alternative to OpenTofu)"},{"location":"CONFIGURATION/#security-recommendations","text":"Always handle sensitive information like passwords, client secrets, and tokens securely. It's recommended to store these in AWS Secrets Manager or using environment variables. Avoid hard-coding sensitive data directly into your configuration files. For more detailed information about Harbor's configuration options, refer to the official Harbor documentation .","title":"Security Recommendations"},{"location":"CONTINUOUS_INTEGRATION/","text":"Continuous Integration This project uses GitHub Actions for continuous integration. Our CI pipeline runs on every push and pull request, performing the following checks: Runs Go tests Checks OpenTofu formatting Validates OpenTofu configurations Runs tflint for additional OpenTofu linting Ensures documentation is up-to-date Performs IAC security scans using Snyk and tfsec Lints Go code using golangci-lint Checks Markdown files for consistent styling For more details, see the .github/workflows/ci.yml file in the repository.","title":"Continuous Integration"},{"location":"CONTINUOUS_INTEGRATION/#continuous-integration","text":"This project uses GitHub Actions for continuous integration. Our CI pipeline runs on every push and pull request, performing the following checks: Runs Go tests Checks OpenTofu formatting Validates OpenTofu configurations Runs tflint for additional OpenTofu linting Ensures documentation is up-to-date Performs IAC security scans using Snyk and tfsec Lints Go code using golangci-lint Checks Markdown files for consistent styling For more details, see the .github/workflows/ci.yml file in the repository.","title":"Continuous Integration"},{"location":"CONTRIBUTING/","text":"Contributing to Harbor on EKS Deployment We love your input! We want to make contributing to this project as easy and transparent as possible, whether it's: Reporting a bug Discussing the current state of the code Submitting a fix Proposing new features Becoming a maintainer We Develop with Github We use github to host code, to track issues and feature requests, as well as accept pull requests. We Use Github Flow , So All Code Changes Happen Through Pull Requests Pull requests are the best way to propose changes to the codebase. We actively welcome your pull requests: Fork the repo and create your branch from develop . If you've added code that should be tested, add tests. If you've changed APIs, update the documentation. Ensure the test suite passes. Make sure your code lints. Issue that pull request! Any contributions you make will be under the MIT Software License In short, when you submit code changes, your submissions are understood to be under the same MIT License that covers the project. Feel free to contact the maintainers if that's a concern. Report bugs using Github's issues We use GitHub issues to track public bugs. Report a bug by opening a new issue ; it's that easy! Write bug reports with detail, background, and sample code Great Bug Reports tend to have: A quick summary and/or background Steps to reproduce Be specific! Give sample code if you can. What you expected would happen What actually happens Notes (possibly including why you think this might be happening, or stuff you tried that didn't work) Use a Consistent Coding Style 2 spaces for indentation rather than tabs You can try running tofu fmt for style unification License By contributing, you agree that your contributions will be licensed under its MIT License. References This document was adapted from the open-source contribution guidelines for Facebook's Draft","title":"Contributing"},{"location":"CONTRIBUTING/#contributing-to-harbor-on-eks-deployment","text":"We love your input! We want to make contributing to this project as easy and transparent as possible, whether it's: Reporting a bug Discussing the current state of the code Submitting a fix Proposing new features Becoming a maintainer","title":"Contributing to Harbor on EKS Deployment"},{"location":"CONTRIBUTING/#we-develop-with-github","text":"We use github to host code, to track issues and feature requests, as well as accept pull requests.","title":"We Develop with Github"},{"location":"CONTRIBUTING/#we-use-github-flow-so-all-code-changes-happen-through-pull-requests","text":"Pull requests are the best way to propose changes to the codebase. We actively welcome your pull requests: Fork the repo and create your branch from develop . If you've added code that should be tested, add tests. If you've changed APIs, update the documentation. Ensure the test suite passes. Make sure your code lints. Issue that pull request!","title":"We Use Github Flow, So All Code Changes Happen Through Pull Requests"},{"location":"CONTRIBUTING/#any-contributions-you-make-will-be-under-the-mit-software-license","text":"In short, when you submit code changes, your submissions are understood to be under the same MIT License that covers the project. Feel free to contact the maintainers if that's a concern.","title":"Any contributions you make will be under the MIT Software License"},{"location":"CONTRIBUTING/#report-bugs-using-githubs-issues","text":"We use GitHub issues to track public bugs. Report a bug by opening a new issue ; it's that easy!","title":"Report bugs using Github's issues"},{"location":"CONTRIBUTING/#write-bug-reports-with-detail-background-and-sample-code","text":"Great Bug Reports tend to have: A quick summary and/or background Steps to reproduce Be specific! Give sample code if you can. What you expected would happen What actually happens Notes (possibly including why you think this might be happening, or stuff you tried that didn't work)","title":"Write bug reports with detail, background, and sample code"},{"location":"CONTRIBUTING/#use-a-consistent-coding-style","text":"2 spaces for indentation rather than tabs You can try running tofu fmt for style unification","title":"Use a Consistent Coding Style"},{"location":"CONTRIBUTING/#license","text":"By contributing, you agree that your contributions will be licensed under its MIT License.","title":"License"},{"location":"CONTRIBUTING/#references","text":"This document was adapted from the open-source contribution guidelines for Facebook's Draft","title":"References"},{"location":"POST_DEPLOYMENT/","text":"Post-Deployment Steps After successfully deploying Harbor on EKS, follow these steps: Retrieve the ELB address: bash kubectl get ingress -n harbor Create a CNAME record in your domain's DNS settings: Host: harbor (or your chosen subdomain) Points to: The ELB address from step 1 TTL: 300 seconds (or as preferred) Access Harbor using your domain and verify the installation. Configure any additional settings in Harbor as needed for your environment. For more detailed post-deployment configuration, refer to the Harbor documentation .","title":"Post-Deployment Steps"},{"location":"POST_DEPLOYMENT/#post-deployment-steps","text":"After successfully deploying Harbor on EKS, follow these steps: Retrieve the ELB address: bash kubectl get ingress -n harbor Create a CNAME record in your domain's DNS settings: Host: harbor (or your chosen subdomain) Points to: The ELB address from step 1 TTL: 300 seconds (or as preferred) Access Harbor using your domain and verify the installation. Configure any additional settings in Harbor as needed for your environment. For more detailed post-deployment configuration, refer to the Harbor documentation .","title":"Post-Deployment Steps"},{"location":"PREREQUISITES/","text":"Prerequisites Before deploying Harbor on EKS using this project, ensure you have the following tools and configurations in place: OpenTofu >= 1.8.0 or Terraform >= 1.0 (as an alternative) AWS CLI (configured with appropriate permissions) kubectl helm Go (for running tests) tflint (for linting) terraform-docs (optional, for documentation generation) Note You can use Terraform as an alternative to OpenTofu for deployment if you encounter issues with OpenTofu\u2019s ongoing development. Installation Commands macOS (using Homebrew) brew install opentofu terraform awscli kubectl helm go tflint terraform-docs Linux (Ubuntu/Debian) # OpenTofu curl -Lo ./tofu.tar.gz https://github.com/opentofu/opentofu/releases/latest/download/tofu_*_linux_amd64.tar.gz tar -xzf tofu.tar.gz chmod +x tofu sudo mv tofu /usr/local/bin/ # Terraform (alternative to OpenTofu) sudo apt-get update && sudo apt-get install -y terraform # AWS CLI sudo apt-get update && sudo apt-get install -y awscli # kubectl sudo curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl # Helm curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash # Go sudo apt-get install -y golang-go # tflint curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash # terraform-docs curl -Lo ./terraform-docs.tar.gz https://github.com/terraform-docs/terraform-docs/releases/download/v0.16.0/terraform-docs-v0.16.0-$(uname)-amd64.tar.gz tar -xzf terraform-docs.tar.gz chmod +x terraform-docs sudo mv terraform-docs /usr/local/bin/ Remember to configure your AWS CLI with the appropriate permissions after installation.","title":"Prerequisites"},{"location":"PREREQUISITES/#prerequisites","text":"Before deploying Harbor on EKS using this project, ensure you have the following tools and configurations in place: OpenTofu >= 1.8.0 or Terraform >= 1.0 (as an alternative) AWS CLI (configured with appropriate permissions) kubectl helm Go (for running tests) tflint (for linting) terraform-docs (optional, for documentation generation)","title":"Prerequisites"},{"location":"PREREQUISITES/#note","text":"You can use Terraform as an alternative to OpenTofu for deployment if you encounter issues with OpenTofu\u2019s ongoing development.","title":"Note"},{"location":"PREREQUISITES/#installation-commands","text":"","title":"Installation Commands"},{"location":"PREREQUISITES/#macos-using-homebrew","text":"brew install opentofu terraform awscli kubectl helm go tflint terraform-docs","title":"macOS (using Homebrew)"},{"location":"PREREQUISITES/#linux-ubuntudebian","text":"# OpenTofu curl -Lo ./tofu.tar.gz https://github.com/opentofu/opentofu/releases/latest/download/tofu_*_linux_amd64.tar.gz tar -xzf tofu.tar.gz chmod +x tofu sudo mv tofu /usr/local/bin/ # Terraform (alternative to OpenTofu) sudo apt-get update && sudo apt-get install -y terraform # AWS CLI sudo apt-get update && sudo apt-get install -y awscli # kubectl sudo curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl # Helm curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash # Go sudo apt-get install -y golang-go # tflint curl -s https://raw.githubusercontent.com/terraform-linters/tflint/master/install_linux.sh | bash # terraform-docs curl -Lo ./terraform-docs.tar.gz https://github.com/terraform-docs/terraform-docs/releases/download/v0.16.0/terraform-docs-v0.16.0-$(uname)-amd64.tar.gz tar -xzf terraform-docs.tar.gz chmod +x terraform-docs sudo mv terraform-docs /usr/local/bin/ Remember to configure your AWS CLI with the appropriate permissions after installation.","title":"Linux (Ubuntu/Debian)"},{"location":"QUICK_START/","text":"Quick Start Guide To deploy Harbor on EKS using this project, follow the steps below. You can use either OpenTofu or Terraform depending on your preference. 1. Clone the Repository bash git clone https://github.com/devsecflow/deploy-harbor-eks.git cd deploy-harbor-eks 2. Choose Your Tool: OpenTofu or Terraform Option 1: OpenTofu Navigate to the tofu directory: bash cd tofu Initialize OpenTofu: bash tofu init Option 2: Terraform (Alternative) Navigate to the terraform directory: bash cd terraform Initialize Terraform: bash terraform init 3. Create a terraform.tfvars File Create the terraform.tfvars file with your specific values, applicable to both OpenTofu and Terraform: hcl region = \"us-west-2\" cluster_name = \"your-cluster-name\" cert_arn = \"arn:aws:acm:us-west-2:your-account-id:certificate/your-certificate-id\" domain_name = \"harbor.yourdomain.com\" vpc_cidr = \"10.0.0.0/16\" 4. Review and Apply the Configuration For OpenTofu bash tofu plan tofu apply For Terraform bash terraform plan terraform apply 5. Post-Deployment After the deployment, follow the post-deployment steps in the POST_DEPLOYMENT.md file for additional configuration and setup. For more detailed instructions, refer to the full documentation.","title":"Quick Start Guide"},{"location":"QUICK_START/#quick-start-guide","text":"To deploy Harbor on EKS using this project, follow the steps below. You can use either OpenTofu or Terraform depending on your preference.","title":"Quick Start Guide"},{"location":"QUICK_START/#1-clone-the-repository","text":"bash git clone https://github.com/devsecflow/deploy-harbor-eks.git cd deploy-harbor-eks","title":"1. Clone the Repository"},{"location":"QUICK_START/#2-choose-your-tool-opentofu-or-terraform","text":"","title":"2. Choose Your Tool: OpenTofu or Terraform"},{"location":"QUICK_START/#option-1-opentofu","text":"Navigate to the tofu directory: bash cd tofu Initialize OpenTofu: bash tofu init","title":"Option 1: OpenTofu"},{"location":"QUICK_START/#option-2-terraform-alternative","text":"Navigate to the terraform directory: bash cd terraform Initialize Terraform: bash terraform init","title":"Option 2: Terraform (Alternative)"},{"location":"QUICK_START/#3-create-a-terraformtfvars-file","text":"Create the terraform.tfvars file with your specific values, applicable to both OpenTofu and Terraform: hcl region = \"us-west-2\" cluster_name = \"your-cluster-name\" cert_arn = \"arn:aws:acm:us-west-2:your-account-id:certificate/your-certificate-id\" domain_name = \"harbor.yourdomain.com\" vpc_cidr = \"10.0.0.0/16\"","title":"3. Create a terraform.tfvars File"},{"location":"QUICK_START/#4-review-and-apply-the-configuration","text":"","title":"4. Review and Apply the Configuration"},{"location":"QUICK_START/#for-opentofu","text":"bash tofu plan tofu apply","title":"For OpenTofu"},{"location":"QUICK_START/#for-terraform","text":"bash terraform plan terraform apply","title":"For Terraform"},{"location":"QUICK_START/#5-post-deployment","text":"After the deployment, follow the post-deployment steps in the POST_DEPLOYMENT.md file for additional configuration and setup. For more detailed instructions, refer to the full documentation.","title":"5. Post-Deployment"},{"location":"SECURITY/","text":"Security Considerations We take security seriously in this project. Here are some key security aspects and considerations: Static Analysis We use tfsec for static analysis of our Terraform configurations. Some checks are excluded based on the specific requirements of our Harbor on EKS deployment: aws-eks-no-public-cluster-access and aws-eks-no-public-cluster-access-to-cidr : Our Harbor instance needs to be publicly accessible. aws-ec2-no-public-egress-sgr : Harbor requires broad egress rules for its functionality. aws-rds-enable-performance-insights : While beneficial, this is not critical for our current deployment. These exclusions are configured in the .tfsec.yml file. We continuously review our security posture and may adjust these exclusions in future updates. Security Features EKS Security : We implement EKS best practices, including proper IAM roles and security groups. RDS Security : The database is deployed in a private subnet with restricted access. Network Security : We use VPC security groups to control inbound and outbound traffic. Encryption : Data at rest is encrypted for EFS and RDS. Reporting Security Issues If you discover a security vulnerability in this project, please report it to us by opening an issue with the label \"security\". We ask that you give us a reasonable amount of time to respond and address the issue before making it public. Security Updates We strive to keep all dependencies up-to-date, especially those with security implications. Regular reviews and updates are part of our maintenance process. Remember, security is a shared responsibility. While we've implemented several security measures, how you configure and use this deployment can also impact its security. Always follow AWS and Kubernetes security best practices in your environment.","title":"Security"},{"location":"SECURITY/#security-considerations","text":"We take security seriously in this project. Here are some key security aspects and considerations:","title":"Security Considerations"},{"location":"SECURITY/#static-analysis","text":"We use tfsec for static analysis of our Terraform configurations. Some checks are excluded based on the specific requirements of our Harbor on EKS deployment: aws-eks-no-public-cluster-access and aws-eks-no-public-cluster-access-to-cidr : Our Harbor instance needs to be publicly accessible. aws-ec2-no-public-egress-sgr : Harbor requires broad egress rules for its functionality. aws-rds-enable-performance-insights : While beneficial, this is not critical for our current deployment. These exclusions are configured in the .tfsec.yml file. We continuously review our security posture and may adjust these exclusions in future updates.","title":"Static Analysis"},{"location":"SECURITY/#security-features","text":"EKS Security : We implement EKS best practices, including proper IAM roles and security groups. RDS Security : The database is deployed in a private subnet with restricted access. Network Security : We use VPC security groups to control inbound and outbound traffic. Encryption : Data at rest is encrypted for EFS and RDS.","title":"Security Features"},{"location":"SECURITY/#reporting-security-issues","text":"If you discover a security vulnerability in this project, please report it to us by opening an issue with the label \"security\". We ask that you give us a reasonable amount of time to respond and address the issue before making it public.","title":"Reporting Security Issues"},{"location":"SECURITY/#security-updates","text":"We strive to keep all dependencies up-to-date, especially those with security implications. Regular reviews and updates are part of our maintenance process. Remember, security is a shared responsibility. While we've implemented several security measures, how you configure and use this deployment can also impact its security. Always follow AWS and Kubernetes security best practices in your environment.","title":"Security Updates"},{"location":"TESTING/","text":"Testing We've included a comprehensive test suite to keep everything ship-shape. Here's how to run it: Navigate to the test directory: bash cd test Set the environment variable to specify whether you're using OpenTofu or Terraform: For OpenTofu : bash export TERRATEST_TERRAFORM_EXECUTABLE=tofu For Terraform : bash export TERRATEST_TERRAFORM_EXECUTABLE=terraform Run the test suite: bash make test This will run through a series of checks based on the tool you've selected: Format checking with tofu fmt or terraform fmt Configuration validation with tofu validate or terraform validate Static code analysis with tflint Documentation generation with terraform-docs (if you have it installed) Unit tests with Go Continuous Integration We've implemented a comprehensive CI pipeline using GitHub Actions. On every push and pull request, our workflow: Runs Go tests Checks Terraform or OpenTofu formatting Validates Terraform or OpenTofu configurations Runs tflint for additional linting Ensures documentation is up-to-date Performs security scans using Snyk and tfsec Lints Go code using golangci-lint Checks Markdown files for consistent styling You can find the workflow configuration in the .github/workflows/ci.yml file. Adding New Tests When adding new features or modifying existing ones, please ensure that appropriate tests are added or updated. This helps maintain the quality and reliability of the project. If you're unsure about how to test a particular component, feel free to open an issue or discuss it in your pull request. Running Individual Tests If you need to run specific tests or checks, you can use the following commands based on your chosen tool. Format Checking To check the formatting of your OpenTofu or Terraform files: For OpenTofu : bash tofu fmt -check -recursive ../tofu For Terraform : bash terraform fmt -check -recursive ../tofu Configuration Validation To validate your configuration: For OpenTofu : bash cd ../tofu tofu init -backend=false tofu validate For Terraform : bash cd ../tofu terraform init -backend=false terraform validate Static Code Analysis To run tflint on your files: cd ../tofu tflint Documentation Generation To generate documentation using terraform-docs : terraform-docs markdown table --output-file ../README.md --output-mode inject ../tofu Go Unit Tests To run the Go unit tests: go test -v ./... Test Coverage We strive to maintain high test coverage for our codebase. While 100% coverage isn't always practical or necessary, we aim for comprehensive coverage of critical paths and edge cases. To view the current test coverage, you can run: go test -cover ./... For a more detailed coverage report, you can use: go test -coverprofile=coverage.out ./... go tool cover -html=coverage.out This will generate an HTML report of your test coverage, which you can view in your browser. Reporting Test Issues If you encounter any issues with the tests or believe a test is incorrectly implemented, please open an issue on our GitHub repository. Provide as much detail as possible, including: The specific test that failed The expected behavior The actual behavior Any error messages or logs Your feedback helps us improve the reliability and effectiveness of our test suite.","title":"Testing"},{"location":"TESTING/#testing","text":"We've included a comprehensive test suite to keep everything ship-shape. Here's how to run it: Navigate to the test directory: bash cd test Set the environment variable to specify whether you're using OpenTofu or Terraform: For OpenTofu : bash export TERRATEST_TERRAFORM_EXECUTABLE=tofu For Terraform : bash export TERRATEST_TERRAFORM_EXECUTABLE=terraform Run the test suite: bash make test This will run through a series of checks based on the tool you've selected: Format checking with tofu fmt or terraform fmt Configuration validation with tofu validate or terraform validate Static code analysis with tflint Documentation generation with terraform-docs (if you have it installed) Unit tests with Go","title":"Testing"},{"location":"TESTING/#continuous-integration","text":"We've implemented a comprehensive CI pipeline using GitHub Actions. On every push and pull request, our workflow: Runs Go tests Checks Terraform or OpenTofu formatting Validates Terraform or OpenTofu configurations Runs tflint for additional linting Ensures documentation is up-to-date Performs security scans using Snyk and tfsec Lints Go code using golangci-lint Checks Markdown files for consistent styling You can find the workflow configuration in the .github/workflows/ci.yml file.","title":"Continuous Integration"},{"location":"TESTING/#adding-new-tests","text":"When adding new features or modifying existing ones, please ensure that appropriate tests are added or updated. This helps maintain the quality and reliability of the project. If you're unsure about how to test a particular component, feel free to open an issue or discuss it in your pull request.","title":"Adding New Tests"},{"location":"TESTING/#running-individual-tests","text":"If you need to run specific tests or checks, you can use the following commands based on your chosen tool.","title":"Running Individual Tests"},{"location":"TESTING/#format-checking","text":"To check the formatting of your OpenTofu or Terraform files: For OpenTofu : bash tofu fmt -check -recursive ../tofu For Terraform : bash terraform fmt -check -recursive ../tofu","title":"Format Checking"},{"location":"TESTING/#configuration-validation","text":"To validate your configuration: For OpenTofu : bash cd ../tofu tofu init -backend=false tofu validate For Terraform : bash cd ../tofu terraform init -backend=false terraform validate","title":"Configuration Validation"},{"location":"TESTING/#static-code-analysis","text":"To run tflint on your files: cd ../tofu tflint","title":"Static Code Analysis"},{"location":"TESTING/#documentation-generation","text":"To generate documentation using terraform-docs : terraform-docs markdown table --output-file ../README.md --output-mode inject ../tofu","title":"Documentation Generation"},{"location":"TESTING/#go-unit-tests","text":"To run the Go unit tests: go test -v ./...","title":"Go Unit Tests"},{"location":"TESTING/#test-coverage","text":"We strive to maintain high test coverage for our codebase. While 100% coverage isn't always practical or necessary, we aim for comprehensive coverage of critical paths and edge cases. To view the current test coverage, you can run: go test -cover ./... For a more detailed coverage report, you can use: go test -coverprofile=coverage.out ./... go tool cover -html=coverage.out This will generate an HTML report of your test coverage, which you can view in your browser.","title":"Test Coverage"},{"location":"TESTING/#reporting-test-issues","text":"If you encounter any issues with the tests or believe a test is incorrectly implemented, please open an issue on our GitHub repository. Provide as much detail as possible, including: The specific test that failed The expected behavior The actual behavior Any error messages or logs Your feedback helps us improve the reliability and effectiveness of our test suite.","title":"Reporting Test Issues"},{"location":"user-guides/","text":"Harbor User Guides Running a Vulnerability Scan with Harbor This guide will walk you through the process of pushing an image to Harbor, running a vulnerability scan, and interpreting the results. We'll use Nginx as our example image. Prerequisites Harbor is deployed and accessible Docker is installed on your local machine You have admin access to your Harbor instance Steps Log in to Harbor Use the Docker CLI to log in to your Harbor instance: bash docker login harbor.yourdomain.com Enter your Harbor credentials when prompted. Create a New Project Log in to the Harbor web interface Click on \"New Project\" Name your project (e.g., \"nginx-test\") Set the project to \"Public\" for this example Click \"OK\" to create the project Configure Automatic Scanning and SBOM Generation In your project, go to the \"Configuration\" tab Under \"Vulnerability scanning\", check \"Automatically scan images on push\" Under \"SBOM generation\", check \"Automatically generate SBOM on push\" Click \"Save\" to apply these settings Pull the Nginx Image Pull the latest Nginx image from Docker Hub: bash docker pull nginx:latest Tag the Nginx Image for Harbor Tag the image with your Harbor registry: bash docker tag nginx:latest harbor.yourdomain.com/nginx-test/nginx:v1 Push the Image to Harbor Push the tagged image to your Harbor registry: bash docker push harbor.yourdomain.com/nginx-test/nginx:v1 View Scan Results In the Harbor web interface, navigate to your \"nginx-test\" project Find the nginx image you just pushed Click on the image name to view details Go to the \"Vulnerabilities\" tab to see the scan results Review the list of vulnerabilities, their severity, and any available fixes View SBOM In the image details page, go to the \"Artifacts\" tab You should see the SBOM artifact associated with your image Click on the SBOM to view or download it Interpret the Results Pay special attention to \"High\" and \"Critical\" vulnerabilities Consider updating to a newer version of Nginx if significant vulnerabilities are found Investigate mitigation strategies for any unresolved vulnerabilities Use the SBOM to understand the components of your image and their licenses Best Practices Regularly scan your images for new vulnerabilities Use the automatic scanning and SBOM generation features for all projects Implement policies to prevent the deployment of images with critical vulnerabilities Review SBOMs to ensure compliance with license requirements and to identify outdated components By following these steps, you can effectively use Harbor to scan your container images for vulnerabilities and generate SBOMs, helping to maintain the security and compliance of your deployments.","title":"Harbor User Guides"},{"location":"user-guides/#harbor-user-guides","text":"","title":"Harbor User Guides"},{"location":"user-guides/#running-a-vulnerability-scan-with-harbor","text":"This guide will walk you through the process of pushing an image to Harbor, running a vulnerability scan, and interpreting the results. We'll use Nginx as our example image.","title":"Running a Vulnerability Scan with Harbor"},{"location":"user-guides/#prerequisites","text":"Harbor is deployed and accessible Docker is installed on your local machine You have admin access to your Harbor instance","title":"Prerequisites"},{"location":"user-guides/#steps","text":"Log in to Harbor Use the Docker CLI to log in to your Harbor instance: bash docker login harbor.yourdomain.com Enter your Harbor credentials when prompted. Create a New Project Log in to the Harbor web interface Click on \"New Project\" Name your project (e.g., \"nginx-test\") Set the project to \"Public\" for this example Click \"OK\" to create the project Configure Automatic Scanning and SBOM Generation In your project, go to the \"Configuration\" tab Under \"Vulnerability scanning\", check \"Automatically scan images on push\" Under \"SBOM generation\", check \"Automatically generate SBOM on push\" Click \"Save\" to apply these settings Pull the Nginx Image Pull the latest Nginx image from Docker Hub: bash docker pull nginx:latest Tag the Nginx Image for Harbor Tag the image with your Harbor registry: bash docker tag nginx:latest harbor.yourdomain.com/nginx-test/nginx:v1 Push the Image to Harbor Push the tagged image to your Harbor registry: bash docker push harbor.yourdomain.com/nginx-test/nginx:v1 View Scan Results In the Harbor web interface, navigate to your \"nginx-test\" project Find the nginx image you just pushed Click on the image name to view details Go to the \"Vulnerabilities\" tab to see the scan results Review the list of vulnerabilities, their severity, and any available fixes View SBOM In the image details page, go to the \"Artifacts\" tab You should see the SBOM artifact associated with your image Click on the SBOM to view or download it Interpret the Results Pay special attention to \"High\" and \"Critical\" vulnerabilities Consider updating to a newer version of Nginx if significant vulnerabilities are found Investigate mitigation strategies for any unresolved vulnerabilities Use the SBOM to understand the components of your image and their licenses","title":"Steps"},{"location":"user-guides/#best-practices","text":"Regularly scan your images for new vulnerabilities Use the automatic scanning and SBOM generation features for all projects Implement policies to prevent the deployment of images with critical vulnerabilities Review SBOMs to ensure compliance with license requirements and to identify outdated components By following these steps, you can effectively use Harbor to scan your container images for vulnerabilities and generate SBOMs, helping to maintain the security and compliance of your deployments.","title":"Best Practices"}]}